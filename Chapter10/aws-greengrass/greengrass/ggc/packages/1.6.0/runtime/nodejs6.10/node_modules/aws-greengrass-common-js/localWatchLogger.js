/*
 * Copyright 2010-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 */
const util = require('util');
const fs = require('fs');
const envVars = require('./envVars');
const config = require('./config');

const LogLevelEnum = Object.freeze({
    NOTSET: 0,
    TRACE: 1,
    DEBUG: 2,
    INFO: 3,
    WARN: 4,
    ERROR: 5,
    FATAL: 6,
});

/*
 * LocalWatchLogger logs message to local watch
 */
class LocalWatchLogger {
    /*
     * Create a local watch logger object with log group name and log stream name
     *
     * @param host a string of host address
     * @param port an int of port number
     * @param logGroupName a string of log group name
     * @param logStreamName a string of log stream name
     */
    constructor(logGroupName, logStreamName, host, port) {
        this._token = envVars.AUTH_TOKEN;
        this._host = host !== undefined ? host : config.DEFAULT_HOST;
        this._port = port !== undefined ? port : config.DEFAULT_PORT;
        this._logGroupName = logGroupName;
        this._logStreamName = logStreamName;

        const levels = ['INFO', 'ERROR', 'DEBUG', 'WARN', 'FATAL'];
        this._buffer_is_free = new Map(levels.map(level => [level, true]));
        this._log_level_to_stream = new Map(levels.map((level) => {
            const pipeFD = parseInt(process.env[`_GG_LOG_FD_${level}`], 10);
            return [level, fs.createWriteStream('', { flags: 'w', fd: pipeFD, autoClose: false })];
            // TODO: test behavior of writeStream in GGC under load
            // Default internal buffer size for writeStream buffer is 16 KB. The buffer is filled when the writeStream
            // is busy, or if the chunk written is too large. Data from the internal buffer is written when possible.
            // In the case that the buffer is filled, it is recommended that we wait for the 'drain' event, although it
            // is possible to keep writing to the buffer. With the current implementation, logs are dropped until the
            // 'drain' event occurs. It is unlikely but possible that the buffer will fill completely.
        }));
        this._min_log_level = LocalWatchLogger._setMinLogLevel();
    }

    /*
     * debug log the args using format string under debug level.
     *
     * @param message a string of log message
     */
    debug(message) {
        this._logf('DEBUG', message);
    }

    /*
     * info log the args using format string under info level.
     *
     * @param message a string of log message
     */
    info(message) {
        this._logf('INFO', message);
    }

    /*
     * warn log the args using format string under warn level.
     *
     * @param message a string of log message
     */
    warn(message) {
        this._logf('WARN', message);
    }

    /*
     * error log the args using format string under error level.
     *
     * @param message a string of log message
     */
    error(message) {
        this._logf('ERROR', message);
    }

    /*
     * critical log the args using format string under error level.
     *
     * @param message a string of log message
     */
    fatal(message) {
        this._logf('FATAL', message);
    }

    /*
     * @api private
     */
    static _setMinLogLevel() {
        const minLogLevel = process.env.LOG_LEVEL;
        if (minLogLevel === undefined || minLogLevel === 'TRACE') {
            return 'NOTSET';
        } else if (minLogLevel === 'DEBUG') {
            return 'DEBUG';
        } else if (minLogLevel === 'INFO') {
            return 'INFO';
        } else if (minLogLevel === 'WARN') {
            return 'WARN';
        } else if (minLogLevel === 'ERROR') {
            return 'ERROR';
        } else if (minLogLevel === 'FATAL') {
            return 'FATAL';
        } else {
            throw new Error(`Could not identify the log level: ${minLogLevel}`);
        }
    }

    /*
     * @api private
     */
    _logf(level, message) {
        if (LogLevelEnum[level] < LogLevelEnum[this._min_log_level]) {
            return;
        }
        // Drop the log if the internal buffer for the writeStream is full to prevent potential memory issues
        if (!this._buffer_is_free.get(level)) {
            return;
        }
        this._emit(level, message);
    }

    /*
     * @api private
     */
    _emit(level, message) {
        const formatMessage = LocalWatchLogger._format(message);
        const writer = this._log_level_to_stream.get(level);
        if (!writer.write(formatMessage)) {
            this._buffer_is_free.set(level, false);
            writer.once('drain', () => { this._buffer_is_free.set(level, true); });
        }
    }

    /*
     * @api private
     */
    static _format(message) {
        const logFormat = '%s\n';
        return util.format(logFormat, message);
    }
}

exports.LocalWatchLogger = LocalWatchLogger;
